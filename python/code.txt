

# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\index.html --- #

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Manager</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.1/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.pm/2.2.0/leaflet.pm.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
<div id="app" class="d-flex vh-100">
    <div class="sidebar bg-light border-end p-3">
        <h5 class="fw-bold">Mode édition</h5>
        <div class="mb-3">
            <label for="tileSelector" class="form-label">Sélectionnez un fond</label>
            <select id="tileSelector" class="form-select">
                <option value="osm">OpenStreetMap</option>
                <option value="cartodb">CartoDB Positron</option>
                <option value="dark">CartoDB Dark</option>
                <option value="satellite">Esri Satellite</option>
            </select>
        </div>
        <div id="geometryList"></div>
    </div>
    <div id="map" class="map"></div>
</div>

<!-- Ajoutez ce bloc pour le titre de la carte -->
<div id="map-title-container" class="map-title-container">
    <div id="mapTitleDisplay" class="map-title-display"></div>
    <div class="map-title-input-container">
        <input type="text" id="mapTitleInput" class="form-control map-title-input" placeholder="Entrez un titre pour la carte" />
        <button id="saveMapTitleBtn" class="btn btn-primary btn-sm">Enregistrer</button>
    </div>
    <i id="toggleTitleIcon" class="bi bi-chevron-up"></i> <!-- Icône de flèche (Bootstrap Icons) -->
</div>

<!-- Menu contextuel pour modifier le style -->
<div id="contextMenu" class="context-menu">
    <div class="context-menu-content">
        <div class="mb-3">
            <label for="contextShapeSelector" class="form-label">Forme du marqueur</label>
            <select id="contextShapeSelector" class="form-select">
                <option value="circle">Cercle</option>
                <option value="square">Carré</option>
                <option value="triangle">Triangle</option>
                <option value="hexagon">Hexagone</option>
            </select>
        </div>
        <div class="mb-3">
            <label for="contextColorPicker" class="form-label">Couleur de remplissage</label>
            <input type="color" id="contextColorPicker" class="form-control" value="#007bff">
        </div>
        <div class="mb-3">
            <label for="contextLineColorPicker" class="form-label">Couleur de la ligne</label>
            <input type="color" id="contextLineColorPicker" class="form-control" value="#000000">
        </div>
        <div class="mb-3">
            <label for="contextOpacitySlider" class="form-label">Transparence</label>
            <input type="range" id="contextOpacitySlider" class="form-range" min="0" max="1" step="0.1" value="1">
        </div>
        <div class="mb-3">
            <label for="contextLineDash" class="form-label">Style de ligne</label>
            <select id="contextLineDash" class="form-select">
                <option value="solid">Continue</option>
                <option value="dashed">Pointillés</option>
                <option value="dotted">Pointillés fins</option>
            </select>
        </div>
        <div class="mb-3">
            <label for="contextLineWeight" class="form-label">Épaisseur de la ligne</label>
            <input type="range" id="contextLineWeight" class="form-range" min="1" max="10" step="1" value="2">
        </div>
        <div class="mb-3">
            <label for="contextMarkerSize" class="form-label">Taille du marqueur</label>
            <input type="range" id="contextMarkerSize" class="form-range" min="10" max="50" step="1" value="24">
        </div>
        <div class="d-flex justify-content-between">
            <button id="contextApplyBtn" class="btn btn-primary btn-sm">Appliquer</button>
            <button id="contextCancelBtn" class="btn btn-secondary btn-sm">Annuler</button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.pm/2.2.0/leaflet.pm.min.js"></script>
<script type="module" src="js/main.js"></script>
</body>
</html>

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\index.html --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\css\styles.css --- #

/* Styles de base pour l'application */
.vh-100 {
    height: 100vh;
}

/* Styles de la sidebar */
.sidebar {
    width: 300px;
    overflow-y: auto;
}

/* Styles de la carte */
.map {
    flex: 1;
    z-index: 0;
    width: 70%; /* Le panneau de la carte occupe 70% de la largeur */
    background: transparent; /* Fond transparent */
    opacity: 1; /* Opacité à 100% */
}

/* Styles pour les éléments de liste */
.list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px;
    margin-bottom: 8px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background-color: white;
}

.list-item:hover {
    background-color: #f8f9fa;
}

.list-item.selected {
    background-color: #e9ecef;
}

.list-item .btn-light {
    padding: 2px 6px;
    font-size: 12px;
}

.list-item input.form-control {
    height: auto;
    padding: 2px 6px;
    font-size: 14px;
}

/* Styles pour le menu contextuel */
.context-menu {
    display: none;
    position: fixed;
    z-index: 1000;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.context-menu-content {
    width: 200px;
}

.context-menu label {
    font-size: 14px;
    margin-bottom: 5px;
}

.context-menu input[type="range"] {
    width: 100%;
}

.context-menu select {
    width: 100%;
}

/* Styles pour les marqueurs personnalisés */
.custom-marker {
    background: none;
    border: none;
}

.cursor-marker {
    width: 24px;
    height: 24px;
    position: relative;
}

.cursor-marker .cross {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
}

.cursor-marker .cross::before,
.cursor-marker .cross::after {
    content: '';
    position: absolute;
    background-color: #000;
}

.cursor-marker .cross::before {
    width: 12px;
    height: 2px;
    top: 5px;
}

.cursor-marker .cross::after {
    width: 2px;
    height: 12px;
    left: 5px;
}

/* Styles pour les contrôles de la carte */
.leaflet-control-custom {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: white;
    border-bottom: 1px solid #ccc;
}

.leaflet-control-custom:last-child {
    border-bottom: none;
}

.leaflet-control-custom svg {
    width: 20px;
    height: 20px;
}

/* Styles pour le conteneur du titre de la carte */
.map-title-container {
    position: absolute;
    top: 10px;
    left: 65%; /* Positionné à 70% de la largeur de l'écran */
    transform: translateX(-50%);
    z-index: 1000;
    background: rgba(255, 255, 255, 0.5); /* Fond blanc transparent à 50% */
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
    text-align: center;
    width: 70%; /* Le conteneur s'étale sur 50% de la largeur */
    max-width: 70%; /* Limite la largeur maximale à 50% */
    min-width: 200px; /* Largeur minimale pour éviter un conteneur trop étroit */
    word-wrap: break-word; /* Permet au texte de passer à la ligne si nécessaire */
    white-space: normal; /* Permet au texte de s'étendre sur plusieurs lignes */
    display: flex;
    align-items: center;
    gap: 10px; /* Espace entre les éléments */
    overflow: hidden; /* Empêche le contenu de déborder */
}

/* Styles pour l'affichage du titre */
.map-title-display {
    flex-grow: 1; /* Prend l'espace disponible */
    white-space: normal; /* Permet au texte de passer à la ligne */
    overflow: hidden; /* Cache le texte qui dépasse */
    word-wrap: break-word; /* Permet au texte de passer à la ligne si nécessaire */
    text-overflow: ellipsis; /* Ajoute des points de suspension si le texte est trop long */
    display: -webkit-box; /* Permet de limiter le nombre de lignes */
    -webkit-line-clamp: 3; /* Limite à 3 lignes maximum */
    -webkit-box-orient: vertical; /* Orientation verticale */
}

/* Styles pour le conteneur de l'input et du bouton */
.map-title-input-container {
    display: flex;
    gap: 10px; /* Espace entre l'input et le bouton */
    flex-shrink: 0; /* Empêche le conteneur de rétrécir */
}

/* Styles pour l'input du titre */
.map-title-input {
    width: 150px; /* Largeur de l'input */
    flex-shrink: 0; /* Empêche l'input de rétrécir */
}

/* Styles pour l'icône de retrait/développement */
#toggleTitleIcon {
    cursor: pointer;
    font-size: 20px;
    color: #007bff;
    flex-shrink: 0; /* Empêche l'icône de rétrécir */
}

/* Styles pour le panneau du titre réduit */
.map-title-container.collapsed {
    height: 40px; /* Hauteur réduite */
    overflow: hidden; /* Cache le contenu */
    transition: height 0.3s ease; /* Animation fluide */
}

/* Styles pour le panneau du titre développé */
.map-title-container.expanded {
    height: auto; /* Hauteur automatique */
    transition: height 0.3s ease; /* Animation fluide */
}

/* Styles pour le sélecteur de forme dans le menu contextuel */
.context-menu select {
    width: 100%;
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 14px;
    margin-bottom: 10px;
}

.context-menu select:focus {
    border-color: #007bff;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\css\styles.css --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\main.js --- #

/* js/main.js */
import { GeometryManager } from './modules/GeometryManager.js';

document.addEventListener('DOMContentLoaded', () => {
    const geometryManager = new GeometryManager();
    geometryManager.init();
});

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\main.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\GeometryManager.js --- #

import { StateManager } from './StateManager.js';
import { MapManager } from './MapManager.js';
import { UIManager } from './UIManager.js';

export class GeometryManager {
    constructor() {
        // Créer StateManager en premier
        this.stateManager = new StateManager();

        // Passer stateManager à MapManager
        this.mapManager = new MapManager(this.stateManager);

        // Initialiser la carte (cela initialise GeometryHandler)
        this.mapManager.initMap();

        // Donner la référence de MapManager à StateManager
        this.stateManager.setMapManager(this.mapManager);

        // Initialiser UIManager avec StateManager
        this.uiManager = new UIManager(this.stateManager);
    }

    /**
     * Initialise l'application.
     */
    init() {
        // Initialiser l'interface utilisateur
        this.uiManager.initUI();
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\GeometryManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\MapManager.js --- #

import { TileLayerManager } from './mapping/layers/TileLayerManager.js';
import { LayerGroupManager } from './mapping/layers/LayerGroupManager.js';
import { MarkerControlManager } from './mapping/markers/MarkerControlManager.js';
import { EventManager } from './mapping/events/EventManager.js';
import { EventHandlers } from './mapping/events/EventHandlers.js';
import { GeometryHandler } from './mapping/geometry/GeometryHandler.js';
import { MarkerFactory } from './markers/MarkerFactory.js'; // Import correct de MarkerFactory
import { LegendManager } from './mapping/LegendManager.js';

export class MapManager {
    constructor(stateManager) {
        if (!stateManager) {
            throw new Error('StateManager is required for MapManager initialization.');
        }

        this.stateManager = stateManager;
        this.map = null;
        this.tileLayerManager = null;
        this.layerGroupManager = null;
        this.geometryHandler = null;
        this.eventManager = null;
        this.legendManager = null;

        // Instanciation de MarkerControlManager
        this.markerControlManager = new MarkerControlManager(this.map, ['circle', 'square', 'triangle', 'hexagon']);

        // Configuration des sources de tuiles
        this.tileSources = {
            osm: {
                url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '&copy; OpenStreetMap contributors'
            },
            cartodb: {
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                attribution: '&copy; CartoDB'
            },
            dark: {
                url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                attribution: '&copy; CartoDB'
            },
            satellite: {
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: '&copy; Esri'
            }
        };
    }

    /**
     * Initialise la carte Leaflet et les modules associés.
     */
    initMap() {
        this._initializeMapElement();
        this._initializeTileLayer();
        this._initializeLayerGroup();
        this._initializeGeometryHandler();
        this._initializeEventHandlers();
        this._initializeMarkerControls();
        this._initializeEditingControls();
        this._initializeLegend();
    }

    /**
     * Initialise l'élément de la carte dans le DOM.
     * @throws {Error} Si l'élément de la carte n'est pas trouvé.
     */
    _initializeMapElement() {
        const mapElement = document.getElementById('map');
        if (!mapElement) {
            throw new Error('Map element not found in the DOM.');
        }
        this.map = L.map('map').setView([37.0902, -95.7129], 4); // Centre la carte sur les États-Unis

        // Mettre à jour la référence de la carte dans MarkerControlManager
        this.markerControlManager.map = this.map;
    }

    /**
     * Initialise la couche de tuiles par défaut (OpenStreetMap).
     */
    _initializeTileLayer() {
        this.tileLayerManager = new TileLayerManager(this.map, this.tileSources);
        this.tileLayerManager.setTileLayer('osm'); // Utilise OpenStreetMap par défaut
    }

    /**
     * Initialise le groupe de couches pour les marqueurs et les géométries.
     */
    _initializeLayerGroup() {
        this.layerGroupManager = new LayerGroupManager(this.map);
    }

    /**
     * Initialise le gestionnaire des géométries.
     */
    _initializeGeometryHandler() {
        this.geometryHandler = new GeometryHandler(this.map, this.layerGroupManager);
    }

    /**
     * Initialise les gestionnaires d'événements pour la carte.
     */
    _initializeEventHandlers() {
        const eventHandlers = new EventHandlers(this);
        this.eventManager = new EventManager(this.map, eventHandlers);
        this.eventManager.initEvents();

        this.map.on('pm:dragend', (e) => {
            const layer = e.layer;
            if (layer && layer.options.customProperties) {
                // Restaurer les propriétés personnalisées
                const properties = layer.options.customProperties;
                layer.setStyle({
                    color: properties.lineColor,
                    fillColor: properties.color,
                    fillOpacity: properties.opacity,
                    weight: properties.lineWeight,
                    dashArray: properties.lineDash === 'solid' ? '' : properties.lineDash === 'dashed' ? '10,10' : '2,6',
                });

                // Mettre à jour les coordonnées dans le StateManager
                const geometryIndex = this.stateManager.geometries.findIndex(
                    geometry => geometry.layer === layer
                );
                if (geometryIndex !== -1) {
                    this.stateManager.updateGeometryCoordinates(geometryIndex, layer.getLatLng());
                }

                // Mettre à jour la légende si nécessaire
                if (this.legendManager) {
                    this.legendManager.updateLegend();
                }
            }
        });
    }

    /**
     * Initialise les contrôles personnalisés pour les marqueurs.
     */
    _initializeMarkerControls() {
        this.markerControlManager.addCustomMarkerControls();
    }

    /**
     * Initialise les contrôles d'édition de Leaflet.PM.
     */
    _initializeEditingControls() {
        if (!this.map.pm) {
            throw new Error('Leaflet.PM plugin is not loaded.');
        }

        // Ajouter les contrôles de dessin avec un libellé personnalisé
        this.map.pm.addControls({
            position: 'topleft',
            drawMarker: false,
            drawCircle: true,
            drawPolygon: true,
            drawPolyline: true,
            drawRectangle: true,
            drawCircleMarker: false,
            editMode: true,
            dragMode: true,
            cutPolygon: false,
            removalMode: false,
            // Personnalisation des libellés des boutons
            customControls: true,
            editControls: {
                edit: 'Editer la forme', // Renommer le bouton "Edit layer"
                cancel: 'Annuler',
                save: 'Enregistrer',
            },
        });

        // Activer les modes d'édition et de suppression globaux
        this.map.pm.enableGlobalEditMode({
            allowEditing: true,
            allowAddingIntersections: true,
            allowRemoval: true,
            editMode: true,
            dragMode: true,
        });

        this.map.pm.enableGlobalRemovalMode();

        // Désactiver l'édition directe des marqueurs
        this.map.pm.setPathOptions({
            allowEditing: false, // Désactiver l'édition directe des marqueurs
        });

        // Gérer l'édition des marqueurs via le bouton "Editer la forme"
        this.map.on('pm:globaleditmodetoggled', (e) => {
            if (e.enabled) {
                console.log('Mode édition activé');
                // Activer l'édition pour tous les marqueurs
                this.map.eachLayer(layer => {
                    if (layer.pm) {
                        layer.pm.enable(); // Activer l'édition pour cette couche
                        console.log('[MapManager] Editing enabled for layer:', layer);
                    }
                });
            } else {
                console.log('Mode édition désactivé');
                // Désactiver l'édition pour tous les marqueurs
                this.map.eachLayer(layer => {
                    if (layer.pm) {
                        layer.pm.disable(); // Désactiver l'édition pour cette couche
                        console.log('[MapManager] Editing disabled for layer:', layer);
                    }
                });

                // Mettre à jour la légende après la fin de l'édition
                if (this.stateManager) {
                    this.stateManager.updateUI();
                }
            }
        });

        // Gérer la modification de la forme
        this.map.on('pm:dragend', (e) => {
            const layer = e.layer;
            if (layer && layer.options.customProperties) {
                // Restaurer les propriétés personnalisées
                const properties = layer.options.customProperties;

                // Appliquer les styles en fonction du type de géométrie
                if (layer instanceof L.CircleMarker) {
                    layer.setStyle({
                        color: properties.lineColor,
                        fillColor: properties.color,
                        fillOpacity: properties.opacity,
                        weight: properties.lineWeight,
                        radius: properties.markerSize / 2
                    });
                } else if (layer instanceof L.Polygon) {
                    layer.setStyle({
                        color: properties.lineColor,
                        fillColor: properties.color,
                        fillOpacity: properties.opacity,
                        weight: properties.lineWeight,
                        dashArray: properties.lineDash === 'solid' ? '' : properties.lineDash === 'dashed' ? '10,10' : '2,6'
                    });
                }

                // Mettre à jour les coordonnées dans le StateManager
                const geometryIndex = this.stateManager.geometries.findIndex(
                    geometry => geometry.layer === layer
                );
                if (geometryIndex !== -1) {
                    this.stateManager.updateGeometryCoordinates(geometryIndex, layer.getLatLng());
                }

                // Mettre à jour la légende si nécessaire
                if (this.legendManager) {
                    this.legendManager.updateLegend();
                }
            }
        });
    }

    /**
     * Gère l'édition des marqueurs.
     * @param {L.Marker|L.CircleMarker} marker - Le marqueur à éditer.
     */
    handleMarkerEdit(marker) {
        // Ouvrir une boîte de dialogue ou un menu contextuel pour modifier la taille du marqueur
        const newSize = prompt('Entrez la nouvelle taille du marqueur (en pixels) :', 24); // Taille par défaut
        if (newSize && !isNaN(newSize)) {
            const size = parseInt(newSize, 10);
            if (size > 0) {
                this.resizeMarker(marker, size); // Redimensionner le marqueur
            } else {
                alert('La taille doit être un nombre positif.');
            }
        }
    }

    /**
     * Redimensionne un marqueur.
     * @param {L.Marker|L.CircleMarker} marker - Le marqueur à redimensionner.
     * @param {number} size - La nouvelle taille du marqueur.
     */
    resizeMarker(marker, size) {
        console.log('[MapManager] Resizing marker to size:', size); // Ajouter un log pour vérifier la taille
        if (marker instanceof L.CircleMarker) {
            // Redimensionner un cercle
            marker.setRadius(size);
        } else if (marker instanceof L.Marker) {
            // Redimensionner un marqueur SVG (carré, triangle, hexagone)
            const icon = marker.getIcon();
            if (icon && icon.options && icon.options.html) {
                const newIcon = L.divIcon({
                    html: icon.options.html.replace(/width="[^"]*"/, `width="${size}"`).replace(/height="[^"]*"/, `height="${size}"`),
                    className: icon.options.className,
                    iconSize: [size, size],
                    iconAnchor: [size / 2, size / 2]
                });
                marker.setIcon(newIcon);
            }
        } else if (marker instanceof L.Polygon) {
            // Redimensionner un marqueur personnalisé (carré, triangle, hexagone)
            const bounds = marker.getBounds();
            const center = bounds.getCenter();
            const scaleFactor = size / (marker.options.markerSize || 24); // Facteur d'échelle

            const newLatLngs = marker.getLatLngs()[0].map(latlng => {
                const latDiff = (latlng.lat - center.lat) * scaleFactor;
                const lngDiff = (latlng.lng - center.lng) * scaleFactor;
                return L.latLng(center.lat + latDiff, center.lng + lngDiff);
            });

            marker.setLatLngs([newLatLngs]);
            marker.options.markerSize = size; // Mettre à jour la taille du marqueur
        }
    }

    /**
     * Initialise la légende de la carte.
     */
    _initializeLegend() {
        this.legendManager = new LegendManager(this.map, this.stateManager);
    }

    /**
     * Change la couche de tuiles affichée sur la carte.
     * @param {string} tileType - Le type de tuile à afficher (osm, cartodb, dark, satellite).
     */
    setTileLayer(tileType) {
        if (!this.tileSources[tileType]) {
            console.error(`Tile type "${tileType}" is not defined.`);
            return;
        }

        if (this.tileLayer) {
            this.map.removeLayer(this.tileLayer);
        }

        const tileConfig = this.tileSources[tileType];
        this.tileLayer = L.tileLayer(tileConfig.url, {
            attribution: tileConfig.attribution
        });

        this.tileLayer.addTo(this.map);
    }

    /**
     * Gère la création de géométries (marqueurs, polygones, etc.).
     * @param {Object} e - L'événement de création.
     */
    handleGeometryCreation(e) {
        const layer = e.layer;
        if (!layer) {
            console.error('[MapManager] Layer is undefined in pm:create event.');
            return;
        }

        if (e.shape === 'Marker') {
            console.log(`[MapManager] Creating marker of type: ${this.markerControlManager.activeMarkerType}`);
            const markerFactory = new MarkerFactory(this.stateManager, this.geometryHandler); // Instancier MarkerFactory
            const newMarker = markerFactory.createMarker(
                this.markerControlManager.activeMarkerType,
                layer.getLatLng(),
                {
                    color: "#007bff",
                    opacity: 1,
                    lineColor: "#000000",
                    lineWeight: 2
                }
            );
            this.map.removeLayer(layer);
            newMarker.addTo(this.layerGroupManager.layerGroup);

            // Désactiver l'édition directe pour le nouveau marqueur
            newMarker.pm.disable();

            // Extraire les coordonnées du marqueur
            let coordinates;
            if (newMarker instanceof L.CircleMarker) {
                coordinates = newMarker.getLatLng();
            } else if (newMarker instanceof L.Polygon) {
                // Pour les marqueurs personnalisés (carré, triangle, hexagone), utiliser le centre du polygone
                const bounds = newMarker.getBounds();
                coordinates = bounds.getCenter();
            }

            const geometry = {
                type: 'CustomMarker',
                markerType: this.markerControlManager.activeMarkerType,
                coordinates: coordinates,
                color: "#007bff",
                opacity: 1,
                lineWeight: 2,
                layer: newMarker
            };
            this.stateManager.addGeometry(geometry);
        } else {
            let geometry;
            if (e.shape === 'Rectangle') {
                const bounds = layer.getBounds();
                const polygon = L.polygon([
                    bounds.getNorthWest(),
                    bounds.getNorthEast(),
                    bounds.getSouthEast(),
                    bounds.getSouthWest()
                ], {
                    color: "#007bff",
                    fillColor: "#007bff",
                    fillOpacity: 1,
                    weight: 2,
                    dashArray: null
                });
                this.map.removeLayer(layer);
                polygon.addTo(this.layerGroupManager.layerGroup);
                geometry = {
                    type: 'Polygon',
                    coordinates: polygon.getLatLngs()[0],
                    color: "#007bff",
                    opacity: 1,
                    lineWeight: 2,
                    lineDash: "solid",
                    layer: polygon
                };
            } else {
                geometry = this.geometryHandler.createGeometryObject(layer);
                if (geometry) {
                    geometry.layer.setStyle({
                        dashArray: null
                    });
                }
            }
            if (geometry) {
                this.stateManager.addGeometry(geometry);
            } else {
                console.error('[MapManager] Failed to create geometry object for layer:', layer);
            }
        }
    }

    /**
     * Gère la suppression de couches (géométries).
     * @param {Object} e - L'événement de suppression.
     */
    handleLayerRemoval(e) {
        const layerToRemove = e.layer;
        if (!layerToRemove) {
            console.error('[MapManager] Layer is undefined in pm:removelayer event.');
            return;
        }

        const geometryIndex = this.stateManager.geometries.findIndex(
            geometry => geometry.layer === layerToRemove
        );

        if (geometryIndex !== -1) {
            e.cancel();
            this.stateManager.deleteGeometry(geometryIndex);
        } else {
            console.error('[MapManager] Layer not found in geometries:', layerToRemove);
        }
    }

    /**
     * Gère l'édition de couches (géométries).
     * @param {Object} e - L'événement d'édition.
     */
    handleLayerEdit(e) {
        const layer = e.layer;
        if (!layer) {
            console.error('[MapManager] Layer is undefined in pm:edit event.');
            return;
        }

        const geometryIndex = this.stateManager.geometries.findIndex(
            geometry => geometry.layer === layer
        );

        if (geometryIndex !== -1) {
            const currentGeometry = this.stateManager.geometries[geometryIndex];
            const updatedGeometry = this.geometryHandler.createGeometryObject(layer);

            if (!updatedGeometry) {
                console.error('[MapManager] Failed to create updated geometry object for layer:', layer);
                return;
            }

            // Préserver les styles personnalisés
            updatedGeometry.color = currentGeometry.color;
            updatedGeometry.lineColor = currentGeometry.lineColor;
            updatedGeometry.opacity = currentGeometry.opacity;
            updatedGeometry.lineWeight = currentGeometry.lineWeight;
            updatedGeometry.lineDash = currentGeometry.lineDash;
            updatedGeometry.markerSize = currentGeometry.markerSize;
            updatedGeometry.markerType = currentGeometry.markerType;

            // Mettre à jour les propriétés personnalisées de la couche
            layer.options.customProperties = {
                color: updatedGeometry.color,
                lineColor: updatedGeometry.lineColor,
                opacity: updatedGeometry.opacity,
                lineWeight: updatedGeometry.lineWeight,
                lineDash: updatedGeometry.lineDash,
                markerSize: updatedGeometry.markerSize,
                markerType: updatedGeometry.markerType
            };

            this.stateManager.geometries[geometryIndex] = updatedGeometry;
            this.stateManager.updateUI();
        }
    }

    /**
     * Gère l'ajout de vertex aux couches (géométries).
     * @param {Object} e - L'événement d'ajout de vertex.
     */
    handleVertexAdded(e) {
        const layer = e.layer;
        if (!layer) {
            console.error('[MapManager] Layer is undefined in pm:vertexadded event.');
            return;
        }

        const geometryIndex = this.stateManager.geometries.findIndex(
            geometry => geometry.layer === layer
        );

        if (geometryIndex !== -1) {
            const updatedGeometry = this.geometryHandler.createGeometryObject(layer);
            if (!updatedGeometry) {
                console.error('[MapManager] Failed to create updated geometry object for layer:', layer);
                return;
            }

            updatedGeometry.color = this.stateManager.geometries[geometryIndex].color;
            updatedGeometry.opacity = this.stateManager.geometries[geometryIndex].opacity;
            this.stateManager.geometries[geometryIndex] = updatedGeometry;
            this.stateManager.updateUI();
        } else {
            console.error('[MapManager] Layer not found in geometries:', layer);
        }
    }

    /**
     * Met à jour la carte avec les géométries actuelles du StateManager.
     */
    updateMap() {
        console.log('[MapManager] Updating map with current geometries.');

        this.layerGroupManager.clearLayers();

        this.stateManager.geometries.forEach((geometry) => {
            if (geometry.layer) {
                if (geometry.type === 'CustomMarker') {
                    this._updateCustomMarker(geometry);
                } else if (geometry.type === 'Circle' || geometry.type === 'Polygon') {
                    this._updateGeometryLayer(geometry);
                } else if (geometry.type === 'Polyline') {
                    this._updatePolylineLayer(geometry);
                }
            }
        });

        // Mettre à jour la légende après avoir mis à jour la carte
        if (this.legendManager) {
            this.legendManager.updateLegend();
        }
    }

    /**
     * Met à jour un marqueur personnalisé sur la carte.
     * @param {Object} geometry - La géométrie du marqueur personnalisé.
     */
    _updateCustomMarker(geometry) {
        console.log('[MapManager] Updating custom marker:', geometry);

        this.map.removeLayer(geometry.layer);
        const markerFactory = new MarkerFactory(this.stateManager, this.geometryHandler); // Instancier MarkerFactory
        const newMarker = markerFactory.createMarker(
            geometry.markerType,
            geometry.coordinates,
            {
                color: geometry.color,
                opacity: geometry.opacity,
                lineColor: geometry.lineColor,
                lineWeight: geometry.lineWeight,
                lineDash: geometry.lineDash,
                markerSize: geometry.markerSize // Ajout de la taille du marqueur
            }
        );
        geometry.layer = newMarker;
        newMarker.addTo(this.layerGroupManager.layerGroup);

        // Désactiver l'édition directe pour le nouveau marqueur
        newMarker.pm.disable();
    }

    /**
     * Met à jour une géométrie (cercle ou polygone) sur la carte.
     * @param {Object} geometry - La géométrie à mettre à jour.
     */
    _updateGeometryLayer(geometry) {
        console.log('[MapManager] Updating geometry layer:', geometry);

        geometry.layer.setStyle({
            color: geometry.lineColor,
            fillColor: geometry.color,
            fillOpacity: geometry.opacity,
            weight: geometry.lineWeight || 2,
            dashArray: geometry.lineDash === 'solid' ? '' : geometry.lineDash === 'dashed' ? '10,10' : '2,6'
        });
        geometry.layer.addTo(this.layerGroupManager.layerGroup);
    }

    /**
     * Met à jour une polyligne sur la carte.
     * @param {Object} geometry - La polyligne à mettre à jour.
     */
    _updatePolylineLayer(geometry) {
        console.log('[MapManager] Updating polyline layer:', geometry);

        geometry.layer.setStyle({
            color: geometry.lineColor,
            opacity: geometry.opacity,
            weight: geometry.lineWeight || 2,
            dashArray: geometry.lineDash === 'solid' ? '' : geometry.lineDash === 'dashed' ? '10,10' : '2,6'
        });
        geometry.layer.addTo(this.layerGroupManager.layerGroup);
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\MapManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\StateManager.js --- #

import { MarkerFactory } from './markers/MarkerFactory.js';

export class StateManager {
    constructor() {
        this.geometries = [];
        this.selectedIndex = null;
        this.mapManager = null;
        this.mapTitle = ''; // Titre de la carte
        this.isTitlePanelCollapsed = false;

        // Ne pas instancier MarkerFactory ici (il sera instancié après que mapManager soit défini)
        this.markerFactory = null;

        // Lie les méthodes au contexte de l'instance
        this.bindMethods();
    }

    /**
     * Lie les méthodes au contexte de l'instance.
     */
    bindMethods() {
        this.openContextMenu = this.openContextMenu.bind(this);
        this.applyStyle = this.applyStyle.bind(this);
        this.deleteGeometry = this.deleteGeometry.bind(this);
        this.updateUI = this.updateUI.bind(this);
        this.updateList = this.updateList.bind(this);
        this.setMapTitle = this.setMapTitle.bind(this);
    }

    /**
     * Définit le titre de la carte.
     * @param {string} title - Le nouveau titre de la carte.
     */
    setMapTitle(title) {
        console.log('[StateManager] Setting map title:', title); // Log pour vérifier le titre
        this.mapTitle = title;
        this.updateUI(); // Mettre à jour l'interface utilisateur
    }

    /**
     * Définit le MapManager.
     * @param {MapManager} mapManager - L'instance de MapManager.
     */
    setMapManager(mapManager) {
        if (!mapManager) {
            throw new Error('MapManager is required for StateManager initialization.');
        }
        this.mapManager = mapManager;

        // Initialiser MarkerFactory après avoir défini mapManager
        this.initializeMarkerFactory();
    }

    /**
     * Initialise MarkerFactory après que GeometryHandler soit disponible.
     */
    initializeMarkerFactory() {
        if (!this.mapManager || !this.mapManager.geometryHandler) {
            throw new Error('MapManager and GeometryHandler must be initialized before creating MarkerFactory.');
        }

        // Instancier MarkerFactory avec StateManager et GeometryHandler
        this.markerFactory = new MarkerFactory(this, this.mapManager.geometryHandler);

        console.log('[StateManager] MarkerFactory initialized:', this.markerFactory);
    }

    /**
     * Ajoute une géométrie à la liste.
     * @param {Object} geometry - La géométrie à ajouter.
     */
    addGeometry(geometry) {
        if (!geometry) {
            console.error('[StateManager] Geometry is undefined in addGeometry.');
            return;
        }

        const typeCount = this.geometries.filter(g => g.type === geometry.type).length + 1;
        geometry.name = `${geometry.type} ${typeCount}`;

        // Assurez-vous que lineDash, lineWeight et lineColor sont correctement stockés
        geometry.lineDash = geometry.lineDash || 'solid'; // Valeur par défaut si non définie
        geometry.lineWeight = geometry.lineWeight || 2; // Valeur par défaut si non définie
        geometry.lineColor = geometry.lineColor || '#000000'; // Valeur par défaut si non définie
        geometry.markerSize = geometry.markerSize || 24; // Taille par défaut du marqueur

        console.log('[StateManager] Adding geometry with:', {
            type: geometry.type,
            color: geometry.color,
            lineColor: geometry.lineColor,
            opacity: geometry.opacity,
            lineDash: geometry.lineDash,
            lineWeight: geometry.lineWeight,
            markerSize: geometry.markerSize
        });

        this.geometries.push(geometry);
        this.updateUI();
    }

    /**
     * Ouvre le menu contextuel pour une géométrie spécifique.
     * @param {number} index - L'index de la géométrie.
     * @param {Event} event - L'événement de clic.
     */
    openContextMenu(index, event) {
        console.log('[StateManager] Opening context menu for geometry at index:', index); // Log pour vérifier l'index
        if (index < 0 || index >= this.geometries.length) {
            console.error('[StateManager] Invalid index in openContextMenu:', index);
            return;
        }

        this.selectedIndex = index;
        const geometry = this.geometries[index];

        const colorPicker = document.getElementById('contextColorPicker');
        const lineColorPicker = document.getElementById('contextLineColorPicker');
        const opacitySlider = document.getElementById('contextOpacitySlider');
        const lineDashSelect = document.getElementById('contextLineDash');
        const lineWeightSlider = document.getElementById('contextLineWeight');
        const markerSizeSlider = document.getElementById('contextMarkerSize');
        const shapeSelector = document.getElementById('contextShapeSelector'); // Sélecteur de forme

        if (!colorPicker || !lineColorPicker || !opacitySlider || !lineDashSelect || !lineWeightSlider || !markerSizeSlider || !shapeSelector) {
            console.error('[StateManager] Context menu elements not found in the DOM.');
            return;
        }

        // Remplir les champs avec les valeurs actuelles de la géométrie
        colorPicker.value = geometry.color || "#007bff";
        lineColorPicker.value = geometry.lineColor || "#000000";
        opacitySlider.value = geometry.opacity || 1;
        lineDashSelect.value = geometry.lineDash || "solid";
        lineWeightSlider.value = geometry.lineWeight || 2;
        markerSizeSlider.value = geometry.markerSize || 24;
        shapeSelector.value = geometry.markerType || "circle"; // Définir la forme actuelle

        // Désactiver la couleur globale pour les polylignes
        if (geometry.type === 'Polyline') {
            colorPicker.disabled = true; // Désactiver la couleur globale
            lineColorPicker.disabled = false; // Activer la couleur de la ligne
        } else {
            colorPicker.disabled = false; // Activer la couleur globale
            lineColorPicker.disabled = false; // Activer la couleur de la ligne
        }

        // Afficher le menu contextuel
        const contextMenu = document.getElementById('contextMenu');
        if (contextMenu) {
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
        } else {
            console.error('[StateManager] Context menu not found in the DOM.');
        }
    }

    /**
     * Applique un style à la géométrie sélectionnée.
     * @param {string} color - La couleur de remplissage.
     * @param {string} lineColor - La couleur de la ligne.
     * @param {number} opacity - L'opacité.
     * @param {string} lineDash - Le style de ligne (solid, dashed, dotted).
     * @param {number} lineWeight - L'épaisseur de la ligne.
     * @param {number} markerSize - La taille du marqueur.
     * @param {string} shape - La nouvelle forme du marqueur.
     */
    applyStyle(color, lineColor, opacity, lineDash, lineWeight, markerSize, shape) {
        console.log('[StateManager] applyStyle called with:', { color, lineColor, opacity, lineDash, lineWeight, markerSize, shape });

        if (this.selectedIndex === null) {
            console.error('[StateManager] No geometry selected in applyStyle.');
            return;
        }

        const geometry = this.geometries[this.selectedIndex];
        if (!geometry) {
            console.error('[StateManager] Selected geometry is undefined in applyStyle.');
            return;
        }

        // Mettre à jour la forme si elle est définie
        if (shape && geometry.type === 'CustomMarker') {
            geometry.markerType = shape; // Mettre à jour le type de marqueur
        }

        // Mettre à jour la taille du marqueur si elle est définie
        if (markerSize && geometry.type === 'CustomMarker') {
            geometry.markerSize = markerSize; // Mettre à jour la taille du marqueur
            this.mapManager.resizeMarker(geometry.layer, markerSize); // Redimensionner le marqueur
        }

        // Ne pas mettre à jour la couleur globale pour les polylignes
        if (geometry.type !== 'Polyline') {
            geometry.color = color;
        }
        geometry.lineColor = lineColor;
        geometry.opacity = opacity;
        geometry.lineDash = lineDash;
        geometry.lineWeight = lineWeight;

        // Mettre à jour les propriétés personnalisées de la couche
        if (geometry.layer && geometry.layer.options.customProperties) {
            geometry.layer.options.customProperties = {
                ...geometry.layer.options.customProperties,
                color: geometry.color,
                opacity: geometry.opacity,
                lineColor: geometry.lineColor,
                lineWeight: geometry.lineWeight,
                lineDash: geometry.lineDash,
                markerSize: geometry.markerSize,
                markerType: geometry.markerType,
            };
        }

        console.log('[StateManager] Geometry updated with:', {
            color: geometry.color,
            lineColor: geometry.lineColor,
            opacity: geometry.opacity,
            lineDash: geometry.lineDash,
            lineWeight: geometry.lineWeight,
            markerSize: geometry.markerSize,
            markerType: geometry.markerType
        });

        if (geometry.layer) {
            if (geometry.type === 'CustomMarker') {
                const options = {
                    color: geometry.color,
                    opacity: geometry.opacity,
                    lineColor: geometry.lineColor,
                    lineWeight: geometry.lineWeight,
                    lineDash: geometry.lineDash,
                    markerSize: geometry.markerSize, // Ajout de la taille du marqueur
                    markerType: geometry.markerType // Ajout du type de marqueur
                };
                console.log('[StateManager] Options passed to MarkerFactory.createMarker:', options);

                // Supprimer l'ancien marqueur
                this.mapManager.map.removeLayer(geometry.layer);

                // Créer un nouveau marqueur avec les nouvelles options
                const newMarker = this.markerFactory.createMarker(
                    geometry.markerType,
                    geometry.coordinates,
                    options
                );
                newMarker.addTo(this.mapManager.layerGroupManager.layerGroup);
                geometry.layer = newMarker;
            } else if (typeof geometry.layer.setStyle === 'function') {
                const style = {
                    color: geometry.lineColor, // Utiliser lineColor pour les contours
                    fillColor: geometry.color,
                    fillOpacity: geometry.opacity,
                    weight: geometry.lineWeight,
                    dashArray: geometry.lineDash === 'solid' ? '' : geometry.lineDash === 'dashed' ? '10,10' : '2,6'
                };
                console.log('[StateManager] Style applied to layer:', style);
                geometry.layer.setStyle(style);
            } else {
                console.error('[StateManager] geometry.layer is not a valid Leaflet layer or does not have setStyle method:', geometry.layer);
            }
        } else {
            console.error('[StateManager] geometry.layer is undefined:', geometry);
        }

        // Mettre à jour la légende après avoir appliqué les styles
        if (this.mapManager.legendManager) {
            this.mapManager.legendManager.updateLegend();
        }

        this.updateUI();
    }

    /**
     * Supprime une géométrie de la liste.
     * @param {number} index - L'index de la géométrie à supprimer.
     */
    deleteGeometry(index) {
        console.log('[StateManager] Deleting geometry at index:', index); // Log pour vérifier l'index
        if (index < 0 || index >= this.geometries.length) {
            console.error('[StateManager] Invalid index in deleteGeometry:', index);
            return;
        }

        const geometry = this.geometries[index];
        if (geometry && geometry.layer) {
            this.mapManager.map.removeLayer(geometry.layer);
        }

        this.geometries.splice(index, 1);

        if (this.selectedIndex === index) {
            this.selectedIndex = null;
        } else if (this.selectedIndex > index) {
            this.selectedIndex--;
        }

        this.updateUI();
    }

    /**
     * Met à jour l'interface utilisateur.
     */
    updateUI() {
        console.log('[StateManager] Updating UI'); // Log pour indiquer que l'UI est en cours de mise à jour

        if (!this.mapManager) {
            console.error('[StateManager] MapManager is not set in StateManager.');
            return;
        }

        // Mettre à jour l'affichage du titre de la carte
        const mapTitleDisplay = document.getElementById('mapTitleDisplay');
        if (mapTitleDisplay) {
            mapTitleDisplay.textContent = this.mapTitle;
        }

        this.updateList();
        this.mapManager.updateMap();
        console.log('[StateManager] UI update complete'); // Log pour indiquer que la mise à jour de l'UI est terminée
    }

    /**
     * Met à jour la liste des géométries dans l'interface utilisateur.
     */
    updateList() {
        console.log('[StateManager] Updating geometry list'); // Log pour vérifier la mise à jour de la liste
        const container = document.getElementById('geometryList');
        if (!container) {
            console.error('[StateManager] Geometry list container not found in the DOM.');
            return;
        }

        container.innerHTML = '';

        this.geometries.forEach((geometry, index) => {
            const item = document.createElement('div');
            item.className = `list-item ${this.selectedIndex === index ? 'selected' : ''}`;

            const nameContainer = document.createElement('div');
            nameContainer.className = 'd-flex align-items-center flex-grow-1';

            // Ajouter un champ d'édition de texte pour le nom
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'form-control me-2';
            nameInput.value = geometry.name;
            nameInput.addEventListener('change', (e) => {
                geometry.name = e.target.value;
                this.updateUI(); // Mettre à jour l'interface utilisateur
                if (this.mapManager.legendManager) {
                    this.mapManager.legendManager.updateLegend(); // Mettre à jour la légende
                }
            });

            const editBtn = document.createElement('button');
            editBtn.className = 'btn btn-warning btn-sm me-2';
            editBtn.textContent = 'Éditer';
            editBtn.onclick = (e) => {
                e.stopPropagation();
                this.openContextMenu(index, e);
            };

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-danger btn-sm';
            deleteBtn.textContent = 'Supprimer';
            deleteBtn.onclick = () => this.deleteGeometry(index);

            nameContainer.appendChild(nameInput);
            item.appendChild(nameContainer);
            item.appendChild(editBtn);
            item.appendChild(deleteBtn);
            container.appendChild(item);
        });
    }
    updateGeometryCoordinates(index, newCoordinates) {
        if (index < 0 || index >= this.geometries.length) {
            console.error('[StateManager] Invalid index in updateGeometryCoordinates:', index);
            return;
        }

        const geometry = this.geometries[index];
        if (geometry) {
            geometry.coordinates = newCoordinates;
            this.updateUI();
        }
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\StateManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\UIManager.js --- #

/* js/modules/UIManager.js */
export class UIManager {
    constructor(stateManager) {
        this.stateManager = stateManager;
    }

    initUI() {
        // Gestionnaire pour le sélecteur de fond de carte
        const tileSelector = document.getElementById('tileSelector');
        if (tileSelector) {
            tileSelector.addEventListener('change', (e) => {
                const selectedTile = e.target.value;
                this.stateManager.mapManager.setTileLayer(selectedTile);
            });
        }

        // Gestionnaire pour le bouton "Enregistrer" du titre de la carte
        const saveMapTitleBtn = document.getElementById('saveMapTitleBtn');
        if (saveMapTitleBtn) {
            saveMapTitleBtn.addEventListener('click', () => {
                const mapTitleInput = document.getElementById('mapTitleInput');
                if (mapTitleInput) {
                    const newTitle = mapTitleInput.value;
                    this.stateManager.setMapTitle(newTitle); // Mettre à jour le titre dans le StateManager
                    const mapTitleDisplay = document.getElementById('mapTitleDisplay');
                    if (mapTitleDisplay) {
                        mapTitleDisplay.textContent = newTitle; // Afficher le nouveau titre
                    }
                }
            });
        }

        // Gestionnaire pour le bouton "Appliquer" du menu contextuel
        const contextApplyBtn = document.getElementById('contextApplyBtn');
        if (contextApplyBtn) {
            contextApplyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const color = document.getElementById('contextColorPicker').value;
                const lineColor = document.getElementById('contextLineColorPicker').value;
                const opacity = parseFloat(document.getElementById('contextOpacitySlider').value);
                const lineDash = document.getElementById('contextLineDash').value;
                const lineWeight = parseInt(document.getElementById('contextLineWeight').value);
                const markerSize = parseInt(document.getElementById('contextMarkerSize').value); // Récupérer la taille du marqueur
                const shape = document.getElementById('contextShapeSelector').value; // Récupérer la nouvelle forme
                this.stateManager.applyStyle(color, lineColor, opacity, lineDash, lineWeight, markerSize, shape); // Passer la nouvelle forme
                document.getElementById('contextMenu').style.display = 'none';
            });
        }

        // Gestionnaire pour le bouton "Annuler" du menu contextuel
        const contextCancelBtn = document.getElementById('contextCancelBtn');
        if (contextCancelBtn) {
            contextCancelBtn.addEventListener('click', () => {
                document.getElementById('contextMenu').style.display = 'none';
            });
        }

        // Fermer le menu contextuel en cliquant à l'extérieur
        document.addEventListener('click', (event) => {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu && !contextMenu.contains(event.target)) {
                contextMenu.style.display = 'none';
            }
        });

        // Gestionnaire pour l'icône de retrait/développement du titre
        const toggleTitleIcon = document.getElementById('toggleTitleIcon');
        if (toggleTitleIcon) {
            toggleTitleIcon.addEventListener('click', () => {
                const mapTitleContainer = document.getElementById('map-title-container');
                if (mapTitleContainer) {
                    mapTitleContainer.classList.toggle('collapsed');
                    mapTitleContainer.classList.toggle('expanded');
                    toggleTitleIcon.classList.toggle('bi-chevron-up');
                    toggleTitleIcon.classList.toggle('bi-chevron-down');
                }
            });
        }
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\UIManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\LegendManager.js --- #

/* js/modules/mapping/LegendManager.js */
export class LegendManager {
    constructor(map, stateManager) {
        this.map = map;
        this.stateManager = stateManager;
        this.legendControl = null;
        this.initLegend();
    }

    /**
     * Initialise la légende de la carte.
     */
    initLegend() {
        const LegendControl = L.Control.extend({
            options: {
                position: 'bottomright'
            },

            onAdd: () => {
                const container = L.DomUtil.create('div', 'legend-control');
                container.style.backgroundColor = 'white';
                container.style.padding = '10px';
                container.style.borderRadius = '4px';
                container.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
                container.style.maxHeight = '300px';
                container.style.overflowY = 'auto';
                container.style.minWidth = '200px';
                return container;
            }
        });

        this.legendControl = new LegendControl();
        this.map.addControl(this.legendControl);
    }

    /**
     * Met à jour la légende avec les géométries actuelles.
     */
    // Dans le fichier LegendManager.js

    updateLegend() {
        console.log('[LegendManager] Updating legend'); // Log pour indiquer que la légende est en cours de mise à jour

        const container = this.legendControl.getContainer();
        container.innerHTML = '<h6 class="mb-2">Légende</h6>';

        if (this.stateManager.geometries.length === 0) {
            container.innerHTML += '<p class="text-muted small mb-0">Aucun élément sur la carte</p>';
            console.log('[LegendManager] No geometries found, legend updated with empty state'); // Log pour indiquer que la légende est vide
            return;
        }

        this.stateManager.geometries.forEach(geometry => {
            console.log('[LegendManager] Adding geometry to legend:', geometry); // Log pour afficher chaque géométrie ajoutée à la légende

            const item = document.createElement('div');
            item.className = 'legend-item d-flex align-items-center mb-2';

            // Créer le symbole
            const symbol = document.createElement('div');
            symbol.className = 'legend-symbol me-2';
            symbol.style.display = 'inline-block';

            // Définir le style du symbole en fonction du type de géométrie
            if (geometry.type === 'CustomMarker') {
                const size = geometry.markerSize || 24; // Utiliser la taille du marqueur ou une valeur par défaut
                symbol.style.width = `${size}px`;
                symbol.style.height = `${size}px`;
                symbol.style.backgroundColor = geometry.color;
                symbol.style.border = `${geometry.lineWeight || 2}px solid ${geometry.lineColor || '#000000'}`;
                // Appliquer la forme du marqueur
                switch (geometry.markerType) {
                    case 'circle':
                        symbol.style.borderRadius = '50%';
                        break;
                    case 'square':
                        symbol.style.borderRadius = '0%';
                        break;
                    case 'triangle':
                        symbol.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                        break;
                    case 'hexagon':
                        symbol.style.clipPath = 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)';
                        break;
                    default:
                        symbol.style.borderRadius = '0%';
                }
            } else if (geometry.type === 'Polyline') {
                // Appliquer les styles de ligne pour les polylignes
                symbol.style.borderTop = `${geometry.lineWeight || 2}px solid ${geometry.lineColor || '#000000'}`;
                symbol.style.opacity = geometry.opacity || 1;
                symbol.style.marginTop = '8px';
                symbol.style.borderTopStyle = this._getLineStyle(geometry.lineDash);
            } else if (geometry.type === 'Polygon') {
                // Appliquer les styles de contour pour les polygones
                symbol.style.backgroundColor = geometry.color;
                symbol.style.opacity = geometry.opacity;
                symbol.style.border = `${geometry.lineWeight || 2}px solid ${geometry.lineColor || '#000000'}`;
                symbol.style.borderStyle = this._getLineStyle(geometry.lineDash);
            } else {
                symbol.style.backgroundColor = geometry.color;
                symbol.style.opacity = geometry.opacity;
                if (geometry.type === 'Circle') {
                    symbol.style.borderRadius = '50%';
                }
            }

            // Ajouter le nom
            const name = document.createElement('span');
            name.className = 'small';
            name.textContent = geometry.name;

            item.appendChild(symbol);
            item.appendChild(name);
            container.appendChild(item);
        });

        console.log('[LegendManager] Legend updated with current geometries'); // Log pour indiquer que la légende a été mise à jour
    }

    /**
     * Retourne le style de ligne en fonction du style de ligne (solid, dashed, dotted).
     * @param {string} lineDash - Le style de ligne (solid, dashed, dotted).
     * @returns {string} - Le style de ligne CSS.
     */
    _getLineStyle(lineDash) {
        switch (lineDash) {
            case 'solid':
                return 'solid';
            case 'dashed':
                return 'dashed';
            case 'dotted':
                return 'dotted';
            default:
                return 'solid';
        }
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\LegendManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\events\EventHandlers.js --- #

/* js/modules/mapping/events/EventHandlers.js */
export class EventHandlers {
    constructor(mapManager) {
        this.mapManager = mapManager;
    }

    /**
     * Gère la création de géométries (marqueurs, polygones, etc.).
     * @param {Object} e - L'événement de création.
     */
    handleGeometryCreation(e) {
        this.mapManager.handleGeometryCreation(e);
    }

    /**
     * Gère la suppression de couches (géométries).
     * @param {Object} e - L'événement de suppression.
     */
    handleLayerRemoval(e) {
        this.mapManager.handleLayerRemoval(e);
    }

    /**
     * Gère l'édition de couches (géométries).
     * @param {Object} e - L'événement d'édition.
     */
    handleLayerEdit(e) {
        this.mapManager.handleLayerEdit(e);
    }

    /**
     * Gère l'ajout de vertex aux couches (géométries).
     * @param {Object} e - L'événement d'ajout de vertex.
     */
    handleVertexAdded(e) {
        this.mapManager.handleVertexAdded(e);
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\events\EventHandlers.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\events\EventManager.js --- #

/* js/modules/mapping/events/EventManager.js */
export class EventManager {
    constructor(map, eventHandlers) {
        this.map = map;
        this.eventHandlers = eventHandlers;
    }

    /**
     * Initialise les gestionnaires d'événements pour la carte.
     */
    initEvents() {
        // Événement de création de géométries
        this.map.on('pm:create', (e) => this.eventHandlers.handleGeometryCreation(e));

        // Événement de suppression de couches
        this.map.on('pm:removelayer', (e) => this.eventHandlers.handleLayerRemoval(e));

        // Événement d'édition de couches
        this.map.on('pm:edit', (e) => this.eventHandlers.handleLayerEdit(e));

        // Événement d'ajout de vertex aux couches
        this.map.on('pm:vertexadded', (e) => this.eventHandlers.handleVertexAdded(e));
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\events\EventManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\geometry\GeometryHandler.js --- #

/* js/modules/mapping/geometry/GeometryHandler.js */
export class GeometryHandler {
    constructor(map, layerGroupManager) {
        this.map = map;
        this.layerGroupManager = layerGroupManager;
    }

    /**
     * Crée un objet géométrique à partir d'une couche Leaflet.
     * @param {L.Layer} layer - La couche Leaflet à convertir en objet géométrique.
     * @returns {Object|null} - L'objet géométrique créé, ou null si la couche n'est pas reconnue.
     */
    // Dans GeometryHandler.js, méthode createGeometryObject()

    createGeometryObject(layer) {
        if (!layer) {
            throw new Error('Layer is undefined in createGeometryObject.');
        }

        const color = layer.options.color || "#007bff";
        const opacity = layer.options.opacity || 1;

        if (layer instanceof L.Circle) {
            return {
                type: 'Circle',
                center: layer.getLatLng(),
                radius: layer.getRadius(),
                color: color,
                opacity: opacity,
                layer: layer
            };
        } else if (layer instanceof L.Polygon) {
            return {
                type: 'Polygon',
                coordinates: layer.getLatLngs()[0] || layer.getLatLngs(),
                color: color,
                opacity: opacity,
                layer: layer
            };
        } else if (layer instanceof L.Polyline) {
            return {
                type: 'Polyline',
                coordinates: layer.getLatLngs(),
                color: color,
                opacity: opacity,
                layer: layer
            };
        } else if (layer instanceof L.Marker) {
            // Gestion des marqueurs personnalisés
            return {
                type: 'CustomMarker',
                coordinates: layer.getLatLng(),
                color: color,
                opacity: opacity,
                layer: layer
            };
        }

        throw new Error('Layer type not recognized.');
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\geometry\GeometryHandler.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\layers\LayerGroupManager.js --- #

/* js/modules/mapping/layers/LayerGroupManager */
export class LayerGroupManager {
    constructor(map) {
        this.map = map;
        this.layerGroup = L.layerGroup().addTo(this.map);
    }

    addLayer(layer) {
        this.layerGroup.addLayer(layer);
    }

    removeLayer(layer) {
        this.layerGroup.removeLayer(layer);
    }

    clearLayers() {
        this.layerGroup.clearLayers();
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\layers\LayerGroupManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\layers\TileLayerManager.js --- #

/* js/modules/mapping/layers/TileLayerManager */
export class TileLayerManager {
    constructor(map, tileSources) {
        this.map = map;
        this.tileSources = tileSources;
        this.tileLayer = null;
    }

    setTileLayer(tileType) {
        if (!this.tileSources[tileType]) {
            throw new Error(`Tile type "${tileType}" is not defined.`);
        }

        if (this.tileLayer) {
            this.map.removeLayer(this.tileLayer);
        }

        const tileConfig = this.tileSources[tileType];
        this.tileLayer = L.tileLayer(tileConfig.url, {
            attribution: tileConfig.attribution
        });

        this.tileLayer.addTo(this.map);
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\layers\TileLayerManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\markers\MarkerControlManager.js --- #

/* js/modules/mapping/markers/MarkerControlManager.js */
export class MarkerControlManager {
    constructor(map, markerTypes) {
        this.map = map;
        this.markerTypes = markerTypes;
        this.activeMarkerType = null; // Initialiser à null
    }

    addCustomMarkerControls() {
        const markerControl = L.Control.extend({
            options: {
                position: 'topleft'
            },

            onAdd: (map) => {
                const container = L.DomUtil.create('div', 'leaflet-control leaflet-bar');

                this.markerTypes.forEach(type => {
                    const button = L.DomUtil.create('a', 'leaflet-control-custom', container);
                    button.href = '#';
                    button.title = `Draw ${type} marker`;

                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '24');
                    svg.setAttribute('height', '24');
                    svg.setAttribute('viewBox', '0 0 24 24');

                    let path;
                    switch (type) {
                        case 'circle':
                            path = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            path.setAttribute('cx', '12');
                            path.setAttribute('cy', '12');
                            path.setAttribute('r', '10');
                            break;
                        case 'square':
                            path = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            path.setAttribute('x', '2');
                            path.setAttribute('y', '2');
                            path.setAttribute('width', '20');
                            path.setAttribute('height', '20');
                            break;
                        case 'triangle':
                            path = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            path.setAttribute('points', '12,2 22,20 2,20');
                            break;
                        case 'hexagon':
                            path = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            path.setAttribute('points', '12,2 20,6 20,18 12,22 4,18 4,6');
                            break;
                    }

                    path.setAttribute('fill', 'transparent');
                    path.setAttribute('stroke', '#000');
                    path.setAttribute('stroke-width', '2');
                    svg.appendChild(path);
                    button.appendChild(svg);

                    L.DomEvent.on(button, 'click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        L.DomEvent.preventDefault(e);
                        this.activeMarkerType = type; // Définir le type de marqueur actif
                        console.log(`Active marker type set to: ${this.activeMarkerType}`); // Log le type de marqueur actif

                        // Activer le mode de dessin pour le marqueur
                        this.map.pm.enableDraw('Marker', {
                            snappable: true,
                            snapDistance: 20,
                            cursorMarker: false,
                            markerStyle: {
                                icon: L.divIcon({
                                    html: `
                                        <div class="cursor-marker">
                                            <div class="cross"></div>
                                        </div>
                                    `,
                                    className: 'cursor-marker',
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 12]
                                })
                            }
                        });
                    });
                });

                return container;
            }
        });

        this.map.addControl(new markerControl());
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\mapping\markers\MarkerControlManager.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\CustomMarkerStyles.js --- #

/* js/modules/markers/CustomMarkerStyles.js */
export const MarkerStyles = {
    circle: {
        className: 'marker-circle',
        iconSize: [24, 24],
        styleTemplate: (color, opacity) => `
            <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" fill="${color}" stroke="#000" stroke-width="2" />
            </svg>
        `
    },
    square: {
        className: 'marker-square',
        iconSize: [24, 24],
        styleTemplate: (color, opacity) => `
            <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <rect x="2" y="2" width="20" height="20" fill="${color}" stroke="#000" stroke-width="2" />
            </svg>
        `
    },
    triangle: {
        className: 'marker-triangle',
        iconSize: [24, 24],
        styleTemplate: (color, opacity) => `
            <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <polygon points="12,2 22,20 2,20" fill="${color}" stroke="#000" stroke-width="2" />
            </svg>
        `
    },
    hexagon: {
        className: 'marker-hexagon',
        iconSize: [24, 24],
        styleTemplate: (color, opacity) => `
            <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <polygon points="12,2 20,6 20,18 12,22 4,18 4,6" fill="${color}" stroke="#000" stroke-width="2" />
            </svg>
        `
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\CustomMarkerStyles.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\MarkerFactory.js --- #

/* js/modules/markers/MarkerFactory.js */
export class MarkerFactory {
    constructor(stateManager, geometryHandler) {
        if (!stateManager) {
            throw new Error('StateManager is required for MarkerFactory initialization.');
        }
        if (!geometryHandler) {
            throw new Error('GeometryHandler is required for MarkerFactory initialization.');
        }
        this.stateManager = stateManager;
        this.geometryHandler = geometryHandler;
    }

    createMarker(type, latlng, options = {}) {
        const defaultStyle = this._getDefaultStyle(options);
        let marker = this._createMarkerByType(type, latlng, defaultStyle);

        if (!marker) {
            console.warn(`[MarkerFactory] Unknown marker type: ${type}. Defaulting to circle.`);
            marker = this._createMarkerByType('circle', latlng, defaultStyle);
        }

        this._addCustomProperties(marker, type, defaultStyle);
        this._setupMarkerEvents(marker);

        return marker;
    }

    _getDefaultStyle(options) {
        return {
            color: options.color || '#007bff',
            opacity: options.opacity || 1,
            lineColor: options.lineColor || '#000000',
            lineWeight: options.lineWeight || 2,
            lineDash: options.lineDash || 'solid',
            markerSize: options.markerSize || 24
        };
    }

    _createMarkerByType(type, latlng, style) {
        const creators = {
            circle: () => this._createCircleMarker(latlng, style),
            square: () => this._createSquareMarker(latlng, style),
            triangle: () => this._createTriangleMarker(latlng, style),
            hexagon: () => this._createHexagonMarker(latlng, style)
        };

        return creators[type] ? creators[type]() : null;
    }

    _addCustomProperties(marker, type, style) {
        marker.options.customProperties = {
            color: style.color,
            lineColor: style.lineColor,
            opacity: style.opacity,
            lineWeight: style.lineWeight,
            lineDash: style.lineDash,
            markerSize: style.markerSize,
            markerType: type
        };
    }

    _setupMarkerEvents(marker) {
        if (marker.pm) {
            marker.pm.enable({ allowEditing: true });

            marker.on('pm:edit', () => {
                const geometryIndex = this.stateManager.geometries.findIndex(
                    geometry => geometry.layer === marker
                );

                if (geometryIndex !== -1) {
                    const updatedGeometry = this.geometryHandler.createGeometryObject(marker);
                    if (updatedGeometry) {
                        // Préserver les styles personnalisés
                        const customProps = marker.options.customProperties;
                        updatedGeometry.color = customProps.color;
                        updatedGeometry.lineColor = customProps.lineColor;
                        updatedGeometry.opacity = customProps.opacity;
                        updatedGeometry.lineWeight = customProps.lineWeight;
                        updatedGeometry.lineDash = customProps.lineDash;
                        updatedGeometry.markerSize = customProps.markerSize;
                        updatedGeometry.markerType = customProps.markerType;

                        this.stateManager.geometries[geometryIndex] = updatedGeometry;
                        this.stateManager.updateUI();
                    }
                }
            });

            marker.on('pm:dragend', () => {
                // Restaurer les styles après le déplacement
                const customProps = marker.options.customProperties;
                marker.setStyle({
                    color: customProps.lineColor,
                    fillColor: customProps.color,
                    fillOpacity: customProps.opacity,
                    weight: customProps.lineWeight,
                    dashArray: this._getDashArray(customProps.lineDash)
                });
            });
        }
    }

    _createCircleMarker(latlng, style) {
        return L.circleMarker(latlng, {
            radius: style.markerSize / 2,
            color: style.lineColor,
            fillColor: style.color,
            fillOpacity: style.opacity,
            weight: style.lineWeight,
            dashArray: this._getDashArray(style.lineDash)
        });
    }

    _createSquareMarker(latlng, style) {
        const size = style.markerSize / 10;
        const halfSize = size / 2;
        const coords = this._getSquareCoords(latlng, halfSize);

        return L.polygon(coords, {
            color: style.lineColor,
            fillColor: style.color,
            fillOpacity: style.opacity,
            weight: style.lineWeight,
            dashArray: this._getDashArray(style.lineDash)
        });
    }

    _createTriangleMarker(latlng, style) {
        const size = style.markerSize / 10;
        const halfSize = size / 2;
        const coords = this._getTriangleCoords(latlng, halfSize);

        return L.polygon(coords, {
            color: style.lineColor,
            fillColor: style.color,
            fillOpacity: style.opacity,
            weight: style.lineWeight,
            dashArray: this._getDashArray(style.lineDash)
        });
    }

    _createHexagonMarker(latlng, style) {
        const size = style.markerSize / 10;
        const halfSize = size / 2;
        const coords = this._getHexagonCoords(latlng, halfSize);

        return L.polygon(coords, {
            color: style.lineColor,
            fillColor: style.color,
            fillOpacity: style.opacity,
            weight: style.lineWeight,
            dashArray: this._getDashArray(style.lineDash)
        });
    }

    _getSquareCoords(latlng, halfSize) {
        return [
            [latlng.lat - halfSize, latlng.lng - halfSize],
            [latlng.lat - halfSize, latlng.lng + halfSize],
            [latlng.lat + halfSize, latlng.lng + halfSize],
            [latlng.lat + halfSize, latlng.lng - halfSize]
        ];
    }

    _getTriangleCoords(latlng, halfSize) {
        return [
            [latlng.lat + halfSize, latlng.lng],
            [latlng.lat - halfSize, latlng.lng + halfSize],
            [latlng.lat - halfSize, latlng.lng - halfSize]
        ];
    }

    _getHexagonCoords(latlng, halfSize) {
        return [
            [latlng.lat - halfSize, latlng.lng],
            [latlng.lat - halfSize / 2, latlng.lng + halfSize],
            [latlng.lat + halfSize / 2, latlng.lng + halfSize],
            [latlng.lat + halfSize, latlng.lng],
            [latlng.lat + halfSize / 2, latlng.lng - halfSize],
            [latlng.lat - halfSize / 2, latlng.lng - halfSize]
        ];
    }

    _getDashArray(lineDash) {
        const dashArrays = {
            solid: '',
            dashed: '10,10',
            dotted: '2,6'
        };
        return dashArrays[lineDash] || '';
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\MarkerFactory.js --- #


# --- Début du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\MarkerUtils.js --- #

/* js/modules/markers/MarkerUtils.js */
import { MarkerStyles } from './CustomMarkerStyles.js';

export const MarkerUtils = {
    // Crée la configuration d'icône pour un type de marqueur
    createIconConfig: (type, color, opacity) => {
        const style = MarkerStyles[type];
        if (!style) {
            console.error(`Invalid marker type: ${type}`);
            return null;
        }

        return {
            html: `<div style="${style.styleTemplate(color, opacity)}"></div>`,
            className: `custom-marker ${style.className}`,
            iconSize: style.iconSize
        };
    },

    // Vérifie si un type de marqueur est valide
    isValidMarkerType: (type) => {
        return Object.keys(MarkerStyles).includes(type);
    },

    // Obtient les dimensions pour un type de marqueur
    getMarkerDimensions: (type) => {
        const style = MarkerStyles[type];
        return style ? style.iconSize : [12, 12]; // Dimensions par défaut
    }
}

# --- Fin du fichier : C:\Users\alano\WebstormProjects\untitled12\js\modules\markers\MarkerUtils.js --- #
